
#include "libptrace_do.h"
#include "mlog.h"

#include <regex.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <limits.h>

#define PROC_STRING "/proc/"
#define MAPS_STRING "/maps"


// Internal helper functions don't need to make it into the main .h file.*/
struct parse_maps *parse_next_line(char *line);

void free_parse_maps_list(struct parse_maps *head);


/***********************************************************************************************************************
 *
 *	get_proc_pid_maps()
 *
 *		Input:
 *			The process id of the target.
 *
 *		Output:
 *			Pointer to a struct parse_maps object. NULL on error.
 *
 *		Purpose:
 *			The parse_maps object pointer will be a pointer to the head of a linked list. This list represents the
 *			different regions of memory allocated by the kernel. This will be a reflection of the entries in the
 *			/proc/PID/maps file.
 *
 **********************************************************************************************************************/
struct parse_maps *get_proc_pid_maps(pid_t target){

  struct parse_maps *map_head = NULL, *map_tail = NULL, *map_tmp;

  int fd, buffer_len;
  int ret_int;

  char *buffer;
  char *tmp_ptr;

  fd = -1;
  // I'm afraid that this function just parses a file and turns it into a linked list. Not very exciting.

  buffer_len = getpagesize();

  if((buffer = (char *) calloc(buffer_len, sizeof(char))) == NULL){
    fprintf(stderr, "calloc(%d, %d): %s\n", buffer_len, (int) sizeof(char), strerror(errno));
    goto CLEAN_UP;
  }


  tmp_ptr = buffer;
  memcpy(tmp_ptr, PROC_STRING, strlen(PROC_STRING));

  tmp_ptr = strchr(buffer, '\0');
  snprintf(tmp_ptr, (PATH_MAX - 1) - (strlen(PROC_STRING) + strlen(MAPS_STRING)), "%d", target);

  tmp_ptr = strchr(buffer, '\0');
  memcpy(tmp_ptr, MAPS_STRING, strlen(MAPS_STRING));

  if((fd = open(buffer, O_RDONLY)) == -1){
    fprintf(stderr, "open(%s, O_RDONLY): %s\n", buffer, strerror(errno));
    goto CLEAN_UP;
  }


  memset(buffer, 0, buffer_len);
  tmp_ptr = buffer;

  while((ret_int = read(fd, tmp_ptr, 1)) > 0){
    if(*tmp_ptr	== '\n'){
      *tmp_ptr = '\0';

      if((map_tmp = parse_next_line(buffer)) == NULL){
	fprintf(stderr, "parse_next_line(%s): %s\n", buffer, strerror(errno));
	goto CLEAN_UP;
      }

      if(!map_head){
	map_head = map_tmp;
	map_tail = map_tmp;
      }else{
	map_tail->next = map_tmp;
	map_tmp->previous = map_tail;
	map_tail = map_tmp;
      }

      memset(buffer, 0, buffer_len);
      tmp_ptr = buffer;

    }else{
      tmp_ptr++;
    }
  }

  if(ret_int == -1){
    fprintf(stderr, "read(%d, %lx, 1): %s\n", fd, (unsigned long) tmp_ptr, strerror(errno));
    goto CLEAN_UP;
  }


  free(buffer);
  close(fd);
  return(map_head);


 CLEAN_UP:

  free(buffer);
  if (fd >=0) {
      close(fd);
  }
  free_parse_maps_list(map_head);
  return(NULL);
}


/***********************************************************************************************************************
 *
 *	parse_next_line()
 *
 *		Input:
 *			A pointer to the string that represents the next line of the file.
 *
 *		Output:
 *			A pointer to the next node, as created from this line.
 *
 *		Purpose:
 *			This is a helper function, not exposed externally. It parses a line and returns a node. Enough said. :)
 *
 **********************************************************************************************************************/
struct parse_maps *parse_next_line(char *line) {
  /* const char regex[] = "([[:xdigit:]]+)-([[:xdigit:]]+) ([rwxp-]+) ([[:xdigit:]]+) ([[:xdigit:]]+):([[:xdigit:]]+) ([[:digit:]]+)[[:space:]]+([[:alnum:]]+)"; */
  const char regex[] = "([[:xdigit:]]+)-([[:xdigit:]]+) ([rwxp-]+) ([[:xdigit:]]+) ([[:xdigit:]]+):([[:xdigit:]]+) ([[:digit:]]+)[[:space:]]+(.*)(deleted)?";

  struct parse_maps *node = NULL;
  regex_t re;
  regmatch_t matches[10];
  int rc;
  char *val = NULL;
  char errbuf[512*8];
  int i;

  if((node = (struct parse_maps *) calloc(1, sizeof(struct parse_maps))) == NULL){
    fprintf(stderr, "calloc(1, %d): %s\n", (int) sizeof(struct parse_maps), strerror(errno));
    goto CLEAN_UP;
  }

  printf("line: '%s'\n", line);
  rc = regcomp(&re, regex, REG_EXTENDED);
  if (rc != 0) {
    regerror(rc,&re,errbuf,sizeof(errbuf));
    printf("(expected) regcomp error string: %s\n", errbuf);
    fprintf(stderr, "could not compile regex: %s\n", strerror(errno));
    goto CLEAN_UP;
  }

  rc = regexec(&re, line, sizeof(matches)/sizeof(matches[0]),
	       (regmatch_t*)&matches, 0);

  if (rc == REG_NOMATCH) {
    printf("not match\n");
    exit(EXIT_FAILURE);
  }
  /* regex match 0 is always whole string */
  i = 1;

  /* match 1 is start_address */
  val = strndup(line+matches[i].rm_so,
		matches[i].rm_eo - matches[i].rm_so);
  if (val == NULL) {
    goto CLEAN_UP;
  }
  node->start_address = strtoul(val, NULL, 16); //segv
  free(val);
  i++;

  /* match 2 is end_address */
  val = strndup(line+matches[i].rm_so,
		matches[i].rm_eo - matches[i].rm_so);
  if (val == NULL) {
    goto CLEAN_UP;
  }
  node->end_address = strtoul(val, NULL, 16);
  free(val);
  i++;

  /* match 3 is perms */
  val = strndup(line+matches[i].rm_so,
		matches[i].rm_eo - matches[i].rm_so);
  if (val == NULL) {
    goto CLEAN_UP;
  }
  if (strstr(val, "r") != NULL) {
    node->perms |= MAPS_READ;
  }
  if (strstr(val, "r") != NULL) {
    node->perms |= MAPS_WRITE;
  }
  if (strstr(val, "x") != NULL) {
    node->perms |= MAPS_EXECUTE;
  }
  if (strstr(val, "p") != NULL) {
    node->perms |= MAPS_PRIVATE;
  }else if (strstr(val, "s") != NULL) {
    node->perms |= MAPS_SHARED;
  }
  free(val);
  i++;

  /* match 4 is offset */
  val = strndup(line+matches[i].rm_so,
		matches[i].rm_eo - matches[i].rm_so);
  if (val == NULL) {
    goto CLEAN_UP;
  }
  node->offset = strtoul(val, NULL, 16);
  free(val);
  i++;

  /* match 5 is dev_major */
  val = strndup(line+matches[i].rm_so,
		matches[i].rm_eo - matches[i].rm_so);
  if (val == NULL) {
    goto CLEAN_UP;
  }
  node->dev_major = strtoul(val, NULL, 16);
  free(val);
  i++;

  /* match 6 is dev_minor */
  val = strndup(line+matches[i].rm_so,
		matches[i].rm_eo - matches[i].rm_so);
  if (val == NULL) {
    goto CLEAN_UP;
  }
  node->dev_minor = strtoul(val, NULL, 16);
  free(val);
  i++;

  /* match 7 is inode */
  val = strndup(line+matches[i].rm_so,
		matches[i].rm_eo - matches[i].rm_so);
  if (val == NULL) {
    goto CLEAN_UP;
  }
  node->inode = strtoul(val, NULL, 10);
  free(val);
  i++;

  /* match 8 is path */
  val = strndup(line+matches[i].rm_so,
		matches[i].rm_eo - matches[i].rm_so);
  if (val == NULL) {
    goto CLEAN_UP;
  }
  memcpy(node->pathname, val, strlen(val));
  free(val);
  i++;

  return(node);

 CLEAN_UP:
  free(val);
  regfree(&re);
  free(node);
  return(NULL);
}


/***********************************************************************************************************************
 *
 *	free_parse_maps_list()
 *
 *		Input:
 *			A pointer to the head of the list.
 *
 *		Output:
 *			Nothing.
 *
 *		Purpose:
 *			Free the members of the linked list.
 *
 **********************************************************************************************************************/
void free_parse_maps_list(struct parse_maps *head){
  struct parse_maps *tmp;

  while(head){
    tmp = head->next;
    free(head);
    head = tmp;
  }
}


/***********************************************************************************************************************
 *
 *	dump_parse_maps_list()
 *
 *		Input:
 *			A pointer to the head of the list.
 *
 *		Output:
 *			Nothing, but it will print representations of the internal data to stdout.
 *
 *		Purpose:
 *			Show us what the linked list looks like. Mostly intended for debugging.
 *
 **********************************************************************************************************************/
void dump_parse_maps_list(struct parse_maps *head){

  while(head){
    printf("--------------------------------------------------------------------------------\n");
    printf("node: %lx\n", (unsigned long) head);
    printf("--------------------------------------------------------------------------------\n");
    printf("start_address:\t\t%lx\n", head->start_address);
    printf("end_address:\t\t%lx\n", head->end_address);
    printf("perms:\t\t\t%05x\n", head->perms);
    printf("offset:\t\t\t%lx\n", head->offset);
    printf("dev_major:\t\t%x\n", head->dev_major);
    printf("dev_minor:\t\t%x\n", head->dev_minor);
    printf("inode:\t\t\t%lx\n", head->inode);
    printf("pathname:\t\t%s\n", head->pathname);

    printf("parse_maps *next:\t%lx\n", (unsigned long) head->next);
    printf("parse_maps *previous:\t%lx\n", (unsigned long) head->previous);
    printf("\n");

    head = head->next;
  }
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=4 tabstop=8 expandtab:
 * :indentSize=4:tabSize=8:noTabs=true:
 */
