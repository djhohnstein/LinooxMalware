#define _GNU_SOURCE

#include "mlog.h"
#include "efi_stuff.h"
#include "z.h"

#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/mount.h>
#include <linux/memfd.h>
#include <sched.h>
#include <strings.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define MEMFDNAME "stage1" //probably should change

static unsigned char inflated_contents[1024*1024];

static int read_var(char *name, unsigned char **contents, size_t *size)
{
    int rc = -1;
    char filename[1024];
    int fd = -1;
    struct stat buf;
    size_t file_len;

    if ((contents == NULL) || (size == NULL)) {
        goto out;
    }

    *contents = NULL;
    snprintf(filename, sizeof(filename), "%s%s-%s", EFIVARS, name, GUID);
    mlog(LINFO, "trying to open %s", filename);
    fd = open(filename, O_RDONLY);
    if (fd < 0) {
        mlog(LFAIL, "open: %s", strerror(errno));
        goto out;
    }
    rc = fstat(fd, &buf);
    if (rc < 0) {
        mlog(LFAIL, "stat: %s", strerror(errno));
        goto out;
    }
    file_len = buf.st_size;
    *size = file_len - sizeof(uint32_t);
    *contents = calloc(1, file_len);
    if (*contents == NULL) {
        goto out;
    }
    rc = read(fd, *contents, file_len);
    if (rc < 0) {
        mlog(LFAIL, "out: %s", strerror(errno));
        goto out;
    }
    memmove(*contents, *contents + sizeof(uint32_t), *size);

 out:
    if (contents && size && rc < 0) {
        if (*contents) {
            free(*contents);
            *contents = NULL;
        }
    }
    if (fd >= 0) {
        close(fd);
    }
    return rc;
}

int main(int argc, char **argv)
{
    int memfd;
    int rc;
    unsigned char *contents;
    size_t inflated_size;
    size_t size;
    struct stat buf;
    const size_t inflated_sz = 1024*1024; /* one meg ought to be enough */
    char *memfd_filename;
    char * const _argv[] = { "sh", NULL };
    const int mountflags = MS_NOEXEC | MS_NODEV | MS_NOSUID | MS_RELATIME;

    log_init("stage1");

    unshare(CLONE_NEWNS);
    if (stat("/proc", &buf) < 0) {
        mkdir("/proc/", S_IRWXU);
        if (mount("proc", "/proc", "proc", mountflags, NULL) < 0) {
            mlog(LFAIL, "couldnt mount /proc: %s", strerror(errno));
        }
    }
    mlog(LINFO, "/proc should exist");

    if (stat("/sys", &buf) < 0) {
        mkdir("/sys/", S_IRWXU);
        if (mount("sysfs", "/sys", "sysfs", mountflags, NULL) < 0) {
            mlog(LFAIL, "couldn't mount /sys: %s", strerror(errno));
        }
    }
    mlog(LINFO, "/sys should exist");

    if (stat("/sys/firmware/efi/efivars", &buf) < 0 || 1) {
        if (mount("efivarfs", "/sys/firmware/efi/efivars", "efivarfs", mountflags, NULL) < 0) {
            mlog(LFAIL, "couldn't mount efivars: %s", strerror(errno));
        }
    }
    mlog(LINFO, "efivars should exist");

    rc = read_var(NAME, &contents, &size);
    if (rc < 0) {
        mlog(LFAIL, "couldn't slurp var");
        goto out;
    }

    memfd = syscall(SYS_memfd_create, MEMFDNAME, MFD_CLOEXEC);
    if (memfd < 0) {
        mlog(LFAIL, "memfd_create: %s", strerror(errno));
        goto out;
    }

    rc = asprintf(&memfd_filename, "/proc/%d/fd/%d", getpid(), memfd);
    if (memfd_filename == NULL) {
        mlog(LFAIL, "asprintf: %s", strerror(errno));
        goto out;
    }

    rc = uncompress_buffer(contents, size, inflated_contents, inflated_sz);
    if (rc < 0) {
        mlog(LFAIL, "something wrong with gunzip");
        goto out;
    }
    inflated_size = rc;

    if (write(memfd, inflated_contents, inflated_size) != inflated_size) {
        mlog(LFAIL, "didn't write entire contents");
        goto out;
    }

    mlog(LINFO, "about to exec");
    rc = execve(memfd_filename, _argv, NULL);
    if (rc < 0) {
        mlog(LFAIL, "exec: %s", strerror(errno));
        goto out;
    }
    /* should never flow out of here */

 out:
    exit(EXIT_FAILURE);
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=4 tabstop=8 expandtab:
 * :indentSize=4:tabSize=8:noTabs=true:
 */
